initial position: 68, 83
(104, 131)

Store a x direction and a y direction - initially 0

read gamepad. direction is in JOY1AW

; ;B, Select, Start, Up, Down, Left, Right
lda JOY1AW
and #0f

1000 up
0100 down
0010 left
0001 right

if it's not zero, then a direction was pressed.

    and #$08        ; Check the Up flag


- if left:
    check wall on left (currently no-op)
    set x direction to left
    set y direction to 0



movement


Checking if sprite would move into background

divide y by 32 to get the row from the pixel
then multiply the rows by 16 since there are 16 bytes per row.

actually can just divide by 2 and clear the low bit

divide x by 32 to get the column from the pixel
add to above

this is the offset into the map
load that and see if it's zero
if so, don't move!

This is just for the top left corner. For moving down or right, need to check +1

divide y by 16
add to x / 32




17 * 32 = 544 tiles offset

I'm actually getting 131


Initial Y coordinate is 0x83 or 131. what row is this? should be 16 or 17
initial x coordinate is 68

This target position should be more like 0x400

I tweaked my shifting of y coordinate to get it into the ballpark but never really did the math

Not working as I expected.
Instead of stopping i should store some values to memory and peek at them.
maybe add a stop button too?
more for tomorrow

Fixed all that

but now if there's a wall and I press DOWN, RIGHT movement stops immediately

need to continue moving right until there's a gap to the bottom, then move down and not right anymore

do I need a subroutine to check the collision along a direction?


Added a HOR_SPEED_LAST and VER_SPEED_LAST

scribbled this down before bed Jan 29:

Check d pad
If direction moves into an open square, set last successful direction and jump to update
If not, leave last successful direction alone

Also if no direction pressed...

Check last successful direction and see if it moves into an open square
If so, move

Formalizing:

Check the D-Pad direction
if actively held direction:
    Compute target X/Y coordinate for leading edge based on direction and current position
    Check if target X/Y coordinate is an open tile (already a subroutine)
    If open:
        save joystick movement as player direction
        jump to movement
    if not open
        # joystick is pressing into a wall, ignore it

else (no joystick movement):
    compute target x/y coordinate for leading edge based on player direction and current position
    Check if target x/y coordinate is an open tile (already a subroutine)
    if open:
        jump to movement
    if not open
        set player direction to 0,0

movement:
    move by player direction



Ah, the collisions and borders are actually a lot easier.
I was considering the black space in non-00 tiles to be places we could go, but it's not
It's a fixed offset - like a trench running through the middle.
consider an 8x8 block centered UNDER the character (4px buffer on each side)
don't let that block move onto a tile unless the tile is 0

 0123456789ABCDEF
0
1
2
3
4    XXXXXXXX
5    XXXXXXXX
6    XXXXXXXX
7    XXXXXXXX
8    XXXXXXXX
9    XXXXXXXX
A    XXXXXXXX
B    XXXXXXXX
C
D
E
F

So top-left is sprite position + 4, 4
Bottom-right is sprite-position + C, C


